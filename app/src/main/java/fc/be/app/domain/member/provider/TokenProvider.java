package fc.be.app.domain.member.provider;

import fc.be.app.domain.member.exception.AuthErrorCode;
import fc.be.app.domain.member.exception.AuthException;
import fc.be.app.domain.member.provider.strategy.TokenGenerator;
import lombok.RequiredArgsConstructor;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Component;

import java.time.Duration;
import java.util.Map;

@Component
@RequiredArgsConstructor
public class TokenProvider {
    private static final String COUNT_PREFIX = "count_";
    private static final String BLOCKED_PREFIX = "blocked_email_";

    private final RedisTemplate<String, String> redisTemplate;

    /**
     * generate and store token generated by generator at key of (prefix+target) for store duration
     * but with frequent request (over max count for count duration), it blocks for blocked duration
     *
     * @param prefix        target prefix
     * @param target        target name
     * @param maxCount      blocked when request exceeds maxCount
     * @param countDuration counting expiration duration
     * @param blockDuration blocking expiration duration
     * @param generator     key generator
     * @param storeDuration store duration
     * @return stored token value
     * @throws AuthException when target email is blocked due to frequent generate request
     */
    public String generateWithFrequentCheck(String prefix, String target, TokenGenerator generator, Duration storeDuration, int maxCount, Duration countDuration, Duration blockDuration) throws AuthException {
        if (isBlocked(prefix, target)) {
            String key = BLOCKED_PREFIX + prefix + target;
            Long expire = redisTemplate.getExpire(key);
            throw new AuthException(AuthErrorCode.VERIFICATION_CODE_GENERATE_BLOCKED, "data", Map.of("expire", expire));
        }
        countGeneration(prefix, target, maxCount, countDuration, blockDuration);
        String key = prefix + target;
        String value = generator.generate();
        redisTemplate.opsForValue().set(key, value, storeDuration);
        return value;
    }

    /**
     * generate token generated by generator and store given value at key of (prefix+token) for store duration
     *
     * @param prefix        target prefix
     * @param value         value to be stored at generated key
     * @param generator     key generator. **ALERT** Each invocation of this method should produce a new, unique value.
     * @param storeDuration store duration
     * @return generated token
     */
    public String generateWithRandomKey(String prefix, String value, TokenGenerator generator, Duration storeDuration) {
        String key = prefix + generator.generate();
        Boolean result;
        while ((result = redisTemplate.opsForValue().setIfAbsent(key, value, storeDuration)) == null || result == false) {
            key = prefix + generator.generate();
        }
        return key.substring(prefix.length());
    }

    /**
     * authenticate for given value. check whether value stored at key of (prefix+target) matches candidate
     *
     * @param prefix    target prefix
     * @param target    target name
     * @param candidate candidate for authentication
     * @return true if authenticated
     * @throws AuthException with CODE_EXPIRED when token is outdated
     * @throws AuthException when INCORRECT_CODE when candidate is incorrect
     */
    public boolean authenticate(String prefix, String target, String candidate) throws AuthException {
        String key = prefix + target;
        String value = redisTemplate.opsForValue().get(key);
        if (value == null) {
            throw new AuthException(AuthErrorCode.CODE_EXPIRED);
        }
        if (!value.equals(candidate)) {
            throw new AuthException(AuthErrorCode.INCORRECT_CODE);
        }
        return true;
    }

    /**
     * remove token by key of (prefix+target)
     *
     * @param prefix target prefix
     * @param target target name
     */
    public void removeToken(String prefix, String target) {
        String key = prefix + target;
        redisTemplate.opsForValue().getAndDelete(key);
    }

    private boolean isBlocked(String prefix, String target) {
        String key = BLOCKED_PREFIX + prefix + target;
        return Boolean.TRUE.equals(redisTemplate.hasKey(key));
    }

    private void countGeneration(String prefix, String target, int maxCount, Duration countDuration, Duration blockDuration) {
        String key = COUNT_PREFIX + prefix + target;
        Long count = redisTemplate.opsForValue().increment(key);
        redisTemplate.expire(key, countDuration);
        if (count != null && count >= maxCount) {
            block(prefix, target, blockDuration);
        }
    }

    private void block(String prefix, String target, Duration blockDuration) {
        String key = BLOCKED_PREFIX + prefix + target;
        redisTemplate.opsForValue().set(key, "blacklisted");
        redisTemplate.expire(key, blockDuration);
    }
}
